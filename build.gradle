import org.gradle.process.internal.ExecAction
import org.gradle.process.internal.ExecActionFactory
import org.gradle.process.internal.ExecException

import javax.inject.Inject
import java.nio.file.Paths

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        jcenter()
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "gradle.plugin.com.matthewprenger:CurseGradle:1.4.0"
    }
}
apply plugin: 'net.minecraftforge.gradle'
// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
apply plugin: 'eclipse'
apply plugin: 'maven-publish'
apply plugin: "com.matthewprenger.cursegradle"


version = 'dev'
group = 'com.github.tony84727' // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = 'unrealuniverse'

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
    // The mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   Snapshot are built nightly.
    // stable_#            Stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not always work.
    // Simply re-run your setup task after changing the mappings to update your workspace.
    mappings channel: 'snapshot', version: '20190719-1.14.3'
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                unrealuniverse {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                unrealuniverse {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            args '--mod', 'unrealuniverse', '--all', '--output', file('src/generated/resources/')

            mods {
                unrealuniverse {
                    source sourceSets.main
                }
            }
        }
    }
}

dependencies {
    // Specify the version of Minecraft to use, If this is any group other then 'net.minecraft' it is assumed
    // that the dep is a ForgeGradle 'patcher' dependency. And it's patches will be applied.
    // The userdev artifact is a special name and will get all sorts of transformations applied to it.
    minecraft 'net.minecraftforge:forge:1.14.4-28.1.104'

    // You may put jars on which you depend on in ./libs or you may define them like so..
    // compile "some.group:artifact:version:classifier"
    // compile "some.group:artifact:version"

    // Real examples
    // compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
    // compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

    // The 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
    // provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // These dependencies get remapped to your current MCP mappings
    // deobf 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // For more info...
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html

}

def secretFile = file('secret.properties')
def curseforgeAPI = ""
if (secretFile.exists()) {
    def secretProperties = new Properties()
    secretFile.withInputStream {
        secretProperties.load(it)
    }
    curseforgeAPI = secretProperties.getProperty("curseforge_token")
}

curseforge {
    apiKey = curseforgeAPI
    project {
        id = '358074'
        releaseType = 'alpha'
    }
}

interface BlenderExportObjParameters extends WorkParameters {
    RegularFileProperty getBlend()

    RegularFileProperty getPythonScript()

    RegularFileProperty getOutput()
}

abstract class BlenderExportObj implements WorkAction<BlenderExportObjParameters> {
    ExecActionFactory factory

    @Inject
    BlenderExportObj(ExecActionFactory factory) {
        this.factory = factory
    }

    @Override
    void execute() {
        ExecAction action = factory.newExecAction()

        if (!parameters.output.get().asFile.parentFile.exists()) {
            parameters.output.get().asFile.parentFile.mkdirs()
        }
        action.commandLine(
                "blender",
                "-b",
                parameters.blend.get().asFile.path,
                "-P",
                parameters.pythonScript.get().asFile.path,
                "--",
                parameters.output.get().asFile.path,
        )
        try {
            action.execute()
        } catch (ExecException e) {
            print(action.getCommandLine().join(" ") + " exec failed")
            throw e
        }
    }
}

class BlenderAssets extends SourceTask {
    WorkQueue workQueue

    @OutputDirectory
    File outputDir

    @Inject
    BlenderAssets(WorkerExecutor workerExecutor) {
        this.workQueue = workerExecutor.noIsolation()
    }

    @TaskAction
    void export() {
        source.visit {
            if (it.isDirectory()) return
            workQueue.submit(BlenderExportObj.class) { BlenderExportObjParameters parameters ->
                parameters.pythonScript = new File("buildSrc/main/python/generate_obj.py")
                parameters.blend = it.file
                // TODO: fix this terrible relative path hack
                parameters.output = Paths.get(outputDir.path, it.relativePath.replaceLastName(it.relativePath.getLastName().replace(".blend", ".obj")).toString()).toFile()
            }
        }
        workQueue.await()
    }
}

def assetOutputDir = "$buildDir/3dModels"

task("blenderAssets", type: BlenderAssets, group: "3dModels") {
    source = fileTree("blender") {
        include "**/*.blend"
    }
    outputDir = file(assetOutputDir)
}

processResources {
    dependsOn blenderAssets
    from("$buildDir/3dModels")
}

